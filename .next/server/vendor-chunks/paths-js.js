"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/paths-js";
exports.ids = ["vendor-chunks/paths-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/paths-js/geom.js":
/*!***************************************!*\
  !*** ./node_modules/paths-js/geom.js ***!
  \***************************************/
/***/ ((module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; })();\n\nvar sq = function sq(x) {\n  return x * x;\n};\n\nvar distPointToPoint = function distPointToPoint(_ref, _ref3) {\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var ax = _ref2[0];\n  var ay = _ref2[1];\n\n  var _ref32 = _slicedToArray(_ref3, 2);\n\n  var bx = _ref32[0];\n  var by = _ref32[1];\n  return Math.sqrt(sq(ax - bx) + sq(ay - by));\n};\n\nvar distPointToParabol = function distPointToParabol(a, f) {\n  var p = distPointToPoint(a, f);\n\n  return p == 0 ? Infinity : sq(p) / (2 * Math.abs(a[1] - f[1]));\n};\n\nvar circumCenter = function circumCenter(a, b, c) {\n  var d = (a[0] - c[0]) * (b[1] - c[1]) - (b[0] - c[0]) * (a[1] - c[1]);\n\n  if (d == 0) return [Infinity, Infinity];\n\n  var xc = (((a[0] - c[0]) * (a[0] + c[0]) + (a[1] - c[1]) * (a[1] + c[1])) / 2 * (b[1] - c[1]) - ((b[0] - c[0]) * (b[0] + c[0]) + (b[1] - c[1]) * (b[1] + c[1])) / 2 * (a[1] - c[1])) / d;\n  var yc = (((b[0] - c[0]) * (b[0] + c[0]) + (b[1] - c[1]) * (b[1] + c[1])) / 2 * (a[0] - c[0]) - ((a[0] - c[0]) * (a[0] + c[0]) + (a[1] - c[1]) * (a[1] + c[1])) / 2 * (b[0] - c[0])) / d;\n  return [xc, yc];\n};\n\nvar parabolsCrossX = function parabolsCrossX(fa, fb, q) {\n  if (fa[1] === fb[1]) return [(fa[0] + fb[0]) / 2, (fa[0] + fb[0]) / 2];\n\n  var s1 = (fa[1] * fb[0] - fa[0] * fb[1] + fa[0] * q - fb[0] * q + Math.sqrt((fa[0] * fa[0] + fa[1] * fa[1] - 2 * fa[0] * fb[0] + fb[0] * fb[0] - 2 * fa[1] * fb[1] + fb[1] * fb[1]) * (fa[1] * fb[1] - fa[1] * q - fb[1] * q + q * q))) / (fa[1] - fb[1]);\n  var s2 = (fa[1] * fb[0] - fa[0] * fb[1] + fa[0] * q - fb[0] * q - Math.sqrt((fa[0] * fa[0] + fa[1] * fa[1] - 2 * fa[0] * fb[0] + fb[0] * fb[0] - 2 * fa[1] * fb[1] + fb[1] * fb[1]) * (fa[1] * fb[1] - fa[1] * q - fb[1] * q + q * q))) / (fa[1] - fb[1]);\n\n  return s1 < s2 ? [s1, s2] : [s2, s1];\n};\n\nvar doHalflinesCross = function doHalflinesCross(sa, sb) {\n  var approx = arguments.length <= 2 || arguments[2] === undefined ? 1e-10 : arguments[2];\n  //sa, sb are Segment instance\n  var dx = sb.ps[0] - sa.ps[0];\n  var dy = sb.ps[1] - sa.ps[1];\n\n  if (sa.m == Infinity) return sa.hp * (sb.m * dx - dy) <= approx && sb.vec[0] * dx <= approx;\n  if (sb.m == Infinity) return sb.hp * (sa.m * dx - dy) >= -approx && sa.vec[0] * dx >= -approx;\n\n  var det = sb.vec[0] * sa.vec[1] - sb.vec[1] * sa.vec[0];\n\n  if (det === 0) return false;\n\n  var u = (dy * sb.vec[0] - dx * sb.vec[1]) / det;\n  var v = (dy * sa.vec[0] - dx * sa.vec[1]) / det;\n\n  return u >= -approx && v >= approx || u >= approx && v >= -approx;\n};\n\nvar matrixTransform = function matrixTransform(points, matrix) {\n  return points.map(function (point) {\n    return {\n      x: point.x * matrix[0] + point.y * matrix[2] + matrix[4],\n      y: point.x * matrix[1] + point.y * matrix[3] + matrix[5]\n    };\n  });\n};\n\nvar transformEllipse = function transformEllipse(rx, ry, ax, m) {\n  var torad = Math.PI / 180;\n  var epsilon = 0.0000000001;\n\n  var c = Math.cos(ax * torad),\n      s = Math.sin(ax * torad);\n  var ma = [rx * (m[0] * c + m[2] * s), rx * (m[1] * c + m[3] * s), ry * (-m[0] * s + m[2] * c), ry * (-m[1] * s + m[3] * c)];\n\n  var J = ma[0] * ma[0] + ma[2] * ma[2],\n      K = ma[1] * ma[1] + ma[3] * ma[3];\n\n  var D = ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) * ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1]));\n\n  var JK = (J + K) / 2;\n\n  if (D < epsilon * JK) {\n    return {\n      rx: Math.sqrt(JK),\n      ry: Math.sqrt(JK),\n      ax: 0,\n      isDegenerate: false\n    };\n  }\n\n  var L = ma[0] * ma[1] + ma[2] * ma[3];\n  D = Math.sqrt(D);\n\n  var l1 = JK + D / 2,\n      l2 = JK - D / 2;\n\n  var newAx = undefined,\n      newRx = undefined,\n      newRy = undefined;\n  newAx = Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon ? 90 : Math.atan(Math.abs(L) > Math.abs(l1 - K) ? (l1 - J) / L : L / (l1 - K)) * 180 / Math.PI;\n\n  if (newAx >= 0) {\n    newRx = Math.sqrt(l1);\n    newRy = Math.sqrt(l2);\n  } else {\n    newAx += 90;\n    newRx = Math.sqrt(l2);\n    newRy = Math.sqrt(l1);\n  }\n\n  return {\n    rx: newRx,\n    ry: newRy,\n    ax: newAx,\n    isDegenerate: newRx < epsilon * newRy || newRy < epsilon * newRx\n  };\n};\n\nexports[\"default\"] = { distPointToPoint: distPointToPoint, distPointToParabol: distPointToParabol, circumCenter: circumCenter,\n  parabolsCrossX: parabolsCrossX, doHalflinesCross: doHalflinesCross, matrixTransform: matrixTransform, transformEllipse: transformEllipse };\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGF0aHMtanMvZ2VvbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsb0NBQW9DLGlDQUFpQyxlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSwyQ0FBMkMsVUFBVSxzQkFBc0IsZUFBZSwyQkFBMkIsMEJBQTBCLGNBQWMsMkNBQTJDLGdDQUFnQyxPQUFPLG1GQUFtRjs7QUFFdHBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wYXRocy1qcy9nZW9tLmpzPzViNzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KSgpO1xuXG52YXIgc3EgPSBmdW5jdGlvbiBzcSh4KSB7XG4gIHJldHVybiB4ICogeDtcbn07XG5cbnZhciBkaXN0UG9pbnRUb1BvaW50ID0gZnVuY3Rpb24gZGlzdFBvaW50VG9Qb2ludChfcmVmLCBfcmVmMykge1xuICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKTtcblxuICB2YXIgYXggPSBfcmVmMlswXTtcbiAgdmFyIGF5ID0gX3JlZjJbMV07XG5cbiAgdmFyIF9yZWYzMiA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKTtcblxuICB2YXIgYnggPSBfcmVmMzJbMF07XG4gIHZhciBieSA9IF9yZWYzMlsxXTtcbiAgcmV0dXJuIE1hdGguc3FydChzcShheCAtIGJ4KSArIHNxKGF5IC0gYnkpKTtcbn07XG5cbnZhciBkaXN0UG9pbnRUb1BhcmFib2wgPSBmdW5jdGlvbiBkaXN0UG9pbnRUb1BhcmFib2woYSwgZikge1xuICB2YXIgcCA9IGRpc3RQb2ludFRvUG9pbnQoYSwgZik7XG5cbiAgcmV0dXJuIHAgPT0gMCA/IEluZmluaXR5IDogc3EocCkgLyAoMiAqIE1hdGguYWJzKGFbMV0gLSBmWzFdKSk7XG59O1xuXG52YXIgY2lyY3VtQ2VudGVyID0gZnVuY3Rpb24gY2lyY3VtQ2VudGVyKGEsIGIsIGMpIHtcbiAgdmFyIGQgPSAoYVswXSAtIGNbMF0pICogKGJbMV0gLSBjWzFdKSAtIChiWzBdIC0gY1swXSkgKiAoYVsxXSAtIGNbMV0pO1xuXG4gIGlmIChkID09IDApIHJldHVybiBbSW5maW5pdHksIEluZmluaXR5XTtcblxuICB2YXIgeGMgPSAoKChhWzBdIC0gY1swXSkgKiAoYVswXSArIGNbMF0pICsgKGFbMV0gLSBjWzFdKSAqIChhWzFdICsgY1sxXSkpIC8gMiAqIChiWzFdIC0gY1sxXSkgLSAoKGJbMF0gLSBjWzBdKSAqIChiWzBdICsgY1swXSkgKyAoYlsxXSAtIGNbMV0pICogKGJbMV0gKyBjWzFdKSkgLyAyICogKGFbMV0gLSBjWzFdKSkgLyBkO1xuICB2YXIgeWMgPSAoKChiWzBdIC0gY1swXSkgKiAoYlswXSArIGNbMF0pICsgKGJbMV0gLSBjWzFdKSAqIChiWzFdICsgY1sxXSkpIC8gMiAqIChhWzBdIC0gY1swXSkgLSAoKGFbMF0gLSBjWzBdKSAqIChhWzBdICsgY1swXSkgKyAoYVsxXSAtIGNbMV0pICogKGFbMV0gKyBjWzFdKSkgLyAyICogKGJbMF0gLSBjWzBdKSkgLyBkO1xuICByZXR1cm4gW3hjLCB5Y107XG59O1xuXG52YXIgcGFyYWJvbHNDcm9zc1ggPSBmdW5jdGlvbiBwYXJhYm9sc0Nyb3NzWChmYSwgZmIsIHEpIHtcbiAgaWYgKGZhWzFdID09PSBmYlsxXSkgcmV0dXJuIFsoZmFbMF0gKyBmYlswXSkgLyAyLCAoZmFbMF0gKyBmYlswXSkgLyAyXTtcblxuICB2YXIgczEgPSAoZmFbMV0gKiBmYlswXSAtIGZhWzBdICogZmJbMV0gKyBmYVswXSAqIHEgLSBmYlswXSAqIHEgKyBNYXRoLnNxcnQoKGZhWzBdICogZmFbMF0gKyBmYVsxXSAqIGZhWzFdIC0gMiAqIGZhWzBdICogZmJbMF0gKyBmYlswXSAqIGZiWzBdIC0gMiAqIGZhWzFdICogZmJbMV0gKyBmYlsxXSAqIGZiWzFdKSAqIChmYVsxXSAqIGZiWzFdIC0gZmFbMV0gKiBxIC0gZmJbMV0gKiBxICsgcSAqIHEpKSkgLyAoZmFbMV0gLSBmYlsxXSk7XG4gIHZhciBzMiA9IChmYVsxXSAqIGZiWzBdIC0gZmFbMF0gKiBmYlsxXSArIGZhWzBdICogcSAtIGZiWzBdICogcSAtIE1hdGguc3FydCgoZmFbMF0gKiBmYVswXSArIGZhWzFdICogZmFbMV0gLSAyICogZmFbMF0gKiBmYlswXSArIGZiWzBdICogZmJbMF0gLSAyICogZmFbMV0gKiBmYlsxXSArIGZiWzFdICogZmJbMV0pICogKGZhWzFdICogZmJbMV0gLSBmYVsxXSAqIHEgLSBmYlsxXSAqIHEgKyBxICogcSkpKSAvIChmYVsxXSAtIGZiWzFdKTtcblxuICByZXR1cm4gczEgPCBzMiA/IFtzMSwgczJdIDogW3MyLCBzMV07XG59O1xuXG52YXIgZG9IYWxmbGluZXNDcm9zcyA9IGZ1bmN0aW9uIGRvSGFsZmxpbmVzQ3Jvc3Moc2EsIHNiKSB7XG4gIHZhciBhcHByb3ggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAxZS0xMCA6IGFyZ3VtZW50c1syXTtcbiAgLy9zYSwgc2IgYXJlIFNlZ21lbnQgaW5zdGFuY2VcbiAgdmFyIGR4ID0gc2IucHNbMF0gLSBzYS5wc1swXTtcbiAgdmFyIGR5ID0gc2IucHNbMV0gLSBzYS5wc1sxXTtcblxuICBpZiAoc2EubSA9PSBJbmZpbml0eSkgcmV0dXJuIHNhLmhwICogKHNiLm0gKiBkeCAtIGR5KSA8PSBhcHByb3ggJiYgc2IudmVjWzBdICogZHggPD0gYXBwcm94O1xuICBpZiAoc2IubSA9PSBJbmZpbml0eSkgcmV0dXJuIHNiLmhwICogKHNhLm0gKiBkeCAtIGR5KSA+PSAtYXBwcm94ICYmIHNhLnZlY1swXSAqIGR4ID49IC1hcHByb3g7XG5cbiAgdmFyIGRldCA9IHNiLnZlY1swXSAqIHNhLnZlY1sxXSAtIHNiLnZlY1sxXSAqIHNhLnZlY1swXTtcblxuICBpZiAoZGV0ID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHUgPSAoZHkgKiBzYi52ZWNbMF0gLSBkeCAqIHNiLnZlY1sxXSkgLyBkZXQ7XG4gIHZhciB2ID0gKGR5ICogc2EudmVjWzBdIC0gZHggKiBzYS52ZWNbMV0pIC8gZGV0O1xuXG4gIHJldHVybiB1ID49IC1hcHByb3ggJiYgdiA+PSBhcHByb3ggfHwgdSA+PSBhcHByb3ggJiYgdiA+PSAtYXBwcm94O1xufTtcblxudmFyIG1hdHJpeFRyYW5zZm9ybSA9IGZ1bmN0aW9uIG1hdHJpeFRyYW5zZm9ybShwb2ludHMsIG1hdHJpeCkge1xuICByZXR1cm4gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9pbnQueCAqIG1hdHJpeFswXSArIHBvaW50LnkgKiBtYXRyaXhbMl0gKyBtYXRyaXhbNF0sXG4gICAgICB5OiBwb2ludC54ICogbWF0cml4WzFdICsgcG9pbnQueSAqIG1hdHJpeFszXSArIG1hdHJpeFs1XVxuICAgIH07XG4gIH0pO1xufTtcblxudmFyIHRyYW5zZm9ybUVsbGlwc2UgPSBmdW5jdGlvbiB0cmFuc2Zvcm1FbGxpcHNlKHJ4LCByeSwgYXgsIG0pIHtcbiAgdmFyIHRvcmFkID0gTWF0aC5QSSAvIDE4MDtcbiAgdmFyIGVwc2lsb24gPSAwLjAwMDAwMDAwMDE7XG5cbiAgdmFyIGMgPSBNYXRoLmNvcyhheCAqIHRvcmFkKSxcbiAgICAgIHMgPSBNYXRoLnNpbihheCAqIHRvcmFkKTtcbiAgdmFyIG1hID0gW3J4ICogKG1bMF0gKiBjICsgbVsyXSAqIHMpLCByeCAqIChtWzFdICogYyArIG1bM10gKiBzKSwgcnkgKiAoLW1bMF0gKiBzICsgbVsyXSAqIGMpLCByeSAqICgtbVsxXSAqIHMgKyBtWzNdICogYyldO1xuXG4gIHZhciBKID0gbWFbMF0gKiBtYVswXSArIG1hWzJdICogbWFbMl0sXG4gICAgICBLID0gbWFbMV0gKiBtYVsxXSArIG1hWzNdICogbWFbM107XG5cbiAgdmFyIEQgPSAoKG1hWzBdIC0gbWFbM10pICogKG1hWzBdIC0gbWFbM10pICsgKG1hWzJdICsgbWFbMV0pICogKG1hWzJdICsgbWFbMV0pKSAqICgobWFbMF0gKyBtYVszXSkgKiAobWFbMF0gKyBtYVszXSkgKyAobWFbMl0gLSBtYVsxXSkgKiAobWFbMl0gLSBtYVsxXSkpO1xuXG4gIHZhciBKSyA9IChKICsgSykgLyAyO1xuXG4gIGlmIChEIDwgZXBzaWxvbiAqIEpLKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ4OiBNYXRoLnNxcnQoSkspLFxuICAgICAgcnk6IE1hdGguc3FydChKSyksXG4gICAgICBheDogMCxcbiAgICAgIGlzRGVnZW5lcmF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgdmFyIEwgPSBtYVswXSAqIG1hWzFdICsgbWFbMl0gKiBtYVszXTtcbiAgRCA9IE1hdGguc3FydChEKTtcblxuICB2YXIgbDEgPSBKSyArIEQgLyAyLFxuICAgICAgbDIgPSBKSyAtIEQgLyAyO1xuXG4gIHZhciBuZXdBeCA9IHVuZGVmaW5lZCxcbiAgICAgIG5ld1J4ID0gdW5kZWZpbmVkLFxuICAgICAgbmV3UnkgPSB1bmRlZmluZWQ7XG4gIG5ld0F4ID0gTWF0aC5hYnMoTCkgPCBlcHNpbG9uICYmIE1hdGguYWJzKGwxIC0gSykgPCBlcHNpbG9uID8gOTAgOiBNYXRoLmF0YW4oTWF0aC5hYnMoTCkgPiBNYXRoLmFicyhsMSAtIEspID8gKGwxIC0gSikgLyBMIDogTCAvIChsMSAtIEspKSAqIDE4MCAvIE1hdGguUEk7XG5cbiAgaWYgKG5ld0F4ID49IDApIHtcbiAgICBuZXdSeCA9IE1hdGguc3FydChsMSk7XG4gICAgbmV3UnkgPSBNYXRoLnNxcnQobDIpO1xuICB9IGVsc2Uge1xuICAgIG5ld0F4ICs9IDkwO1xuICAgIG5ld1J4ID0gTWF0aC5zcXJ0KGwyKTtcbiAgICBuZXdSeSA9IE1hdGguc3FydChsMSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJ4OiBuZXdSeCxcbiAgICByeTogbmV3UnksXG4gICAgYXg6IG5ld0F4LFxuICAgIGlzRGVnZW5lcmF0ZTogbmV3UnggPCBlcHNpbG9uICogbmV3UnkgfHwgbmV3UnkgPCBlcHNpbG9uICogbmV3UnhcbiAgfTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0geyBkaXN0UG9pbnRUb1BvaW50OiBkaXN0UG9pbnRUb1BvaW50LCBkaXN0UG9pbnRUb1BhcmFib2w6IGRpc3RQb2ludFRvUGFyYWJvbCwgY2lyY3VtQ2VudGVyOiBjaXJjdW1DZW50ZXIsXG4gIHBhcmFib2xzQ3Jvc3NYOiBwYXJhYm9sc0Nyb3NzWCwgZG9IYWxmbGluZXNDcm9zczogZG9IYWxmbGluZXNDcm9zcywgbWF0cml4VHJhbnNmb3JtOiBtYXRyaXhUcmFuc2Zvcm0sIHRyYW5zZm9ybUVsbGlwc2U6IHRyYW5zZm9ybUVsbGlwc2UgfTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/paths-js/geom.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/paths-js/path.js":
/*!***************************************!*\
  !*** ./node_modules/paths-js/path.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nvar _geom = __webpack_require__(/*! ./geom */ \"(ssr)/./node_modules/paths-js/geom.js\");\n\nvar Path = function Path(init) {\n  var _instructions = init || [];\n\n  var push = function push(arr, el) {\n    var copy = arr.slice(0, arr.length);\n    copy.push(el);\n    return copy;\n  };\n\n  var areEqualPoints = function areEqualPoints(_ref, _ref3) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    var a1 = _ref2[0];\n    var b1 = _ref2[1];\n\n    var _ref32 = _slicedToArray(_ref3, 2);\n\n    var a2 = _ref32[0];\n    var b2 = _ref32[1];\n    return a1 === a2 && b1 === b2;\n  };\n\n  var trimZeros = function trimZeros(string, char) {\n    var l = string.length;\n    while (string.charAt(l - 1) === '0') {\n      l = l - 1;\n    }\n    if (string.charAt(l - 1) === '.') {\n      l = l - 1;\n    }\n    return string.substr(0, l);\n  };\n\n  var round = function round(number, digits) {\n    var str = number.toFixed(digits);\n    return trimZeros(str);\n  };\n\n  var printInstrunction = function printInstrunction(_ref4) {\n    var command = _ref4.command;\n    var params = _ref4.params;\n\n    var numbers = params.map(function (param) {\n      return round(param, 6);\n    });\n    return command + ' ' + numbers.join(' ');\n  };\n\n  var point = function point(_ref5, prev) {\n    var command = _ref5.command;\n    var params = _ref5.params;\n\n    switch (command) {\n      case 'M':\n        return [params[0], params[1]];\n      case 'L':\n        return [params[0], params[1]];\n      case 'H':\n        return [params[0], prev[1]];\n      case 'V':\n        return [prev[0], params[0]];\n      case 'Z':\n        return null;\n      case 'C':\n        return [params[4], params[5]];\n      case 'S':\n        return [params[2], params[3]];\n      case 'Q':\n        return [params[2], params[3]];\n      case 'T':\n        return [params[0], params[1]];\n      case 'A':\n        return [params[5], params[6]];\n    }\n  };\n\n  var transformParams = function transformParams(instruction, matrix, prev) {\n    var p = instruction.params;\n\n    var transformer = {\n      'V': function V(instruction, matrix, prev) {\n        var pts = [{ x: prev[0], y: p[0] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n        if (newPts[0].x === (0, _geom.matrixTransform)([{ x: prev[0], y: prev[1] }], matrix)[0].x) {\n          return {\n            command: 'V',\n            params: [newPts[0].y]\n          };\n        } else {\n          return {\n            command: 'L',\n            params: [newPts[0].x, newPts[0].y]\n          };\n        }\n      },\n      'H': function H(instruction, matrix, prev) {\n        var pts = [{ x: p[0], y: prev[1] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n        if (newPts[0].y === (0, _geom.matrixTransform)([{ x: prev[0], y: prev[1] }], matrix)[0].y) {\n          return {\n            command: 'H',\n            params: [newPts[0].x]\n          };\n        } else {\n          return {\n            command: 'L',\n            params: [newPts[0].x, newPts[0].y]\n          };\n        }\n      },\n      'A': function A(instruction, matrix, prev) {\n        // transform rx, ry, and x-axis rotation\n        var r = (0, _geom.transformEllipse)(p[0], p[1], p[2], matrix);\n\n        var sweepFlag = p[4];\n        if (matrix[0] * matrix[3] - matrix[1] * matrix[2] < 0) {\n          sweepFlag = sweepFlag ? '0' : '1';\n        }\n\n        // transform endpoint\n        var pts = [{ x: p[5], y: p[6] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n\n        if (r.isDegenerate) {\n          return {\n            command: 'L',\n            params: [newPts[0].x, newPts[0].y]\n          };\n        } else {\n          return {\n            command: 'A',\n            params: [r.rx, r.ry, r.ax, p[3], sweepFlag, newPts[0].x, newPts[0].y]\n          };\n        }\n      },\n      'C': function C(instruction, matrix, prev) {\n        var pts = [{ x: p[0], y: p[1] }, { x: p[2], y: p[3] }, { x: p[4], y: p[5] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n        return {\n          command: 'C',\n          params: [newPts[0].x, newPts[0].y, newPts[1].x, newPts[1].y, newPts[2].x, newPts[2].y]\n        };\n      },\n      'Z': function Z(instruction, matrix, prev) {\n        return {\n          command: 'Z',\n          params: []\n        };\n      },\n      'default': function _default(instruction, matrix, prev) {\n        var pts = [{ x: p[0], y: p[1] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n        var newParams = instruction.params.slice(0, instruction.params.length);\n        newParams.splice(0, 2, newPts[0].x, newPts[0].y);\n        return {\n          command: instruction.command,\n          params: newParams\n        };\n      }\n    };\n\n    if (transformer[instruction.command]) {\n      return transformer[instruction.command](instruction, matrix, prev);\n    } else {\n      return transformer['default'](instruction, matrix, prev);\n    }\n  };\n\n  var verbosify = function verbosify(keys, f) {\n    return function (a) {\n      var args = typeof a === 'object' ? keys.map(function (k) {\n        return a[k];\n      }) : arguments;\n      return f.apply(null, args);\n    };\n  };\n\n  var plus = function plus(instruction) {\n    return Path(push(_instructions, instruction));\n  };\n\n  return {\n    moveto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'M',\n        params: [x, y]\n      });\n    }),\n    lineto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'L',\n        params: [x, y]\n      });\n    }),\n    hlineto: verbosify(['x'], function (x) {\n      return plus({\n        command: 'H',\n        params: [x]\n      });\n    }),\n    vlineto: verbosify(['y'], function (y) {\n      return plus({\n        command: 'V',\n        params: [y]\n      });\n    }),\n    closepath: function closepath() {\n      return plus({\n        command: 'Z',\n        params: []\n      });\n    },\n    curveto: verbosify(['x1', 'y1', 'x2', 'y2', 'x', 'y'], function (x1, y1, x2, y2, x, y) {\n      return plus({\n        command: 'C',\n        params: [x1, y1, x2, y2, x, y]\n      });\n    }),\n    smoothcurveto: verbosify(['x2', 'y2', 'x', 'y'], function (x2, y2, x, y) {\n      return plus({\n        command: 'S',\n        params: [x2, y2, x, y]\n      });\n    }),\n    qcurveto: verbosify(['x1', 'y1', 'x', 'y'], function (x1, y1, x, y) {\n      return plus({\n        command: 'Q',\n        params: [x1, y1, x, y]\n      });\n    }),\n    smoothqcurveto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'T',\n        params: [x, y]\n      });\n    }),\n    arc: verbosify(['rx', 'ry', 'xrot', 'largeArcFlag', 'sweepFlag', 'x', 'y'], function (rx, ry, xrot, largeArcFlag, sweepFlag, x, y) {\n      return plus({\n        command: 'A',\n        params: [rx, ry, xrot, largeArcFlag, sweepFlag, x, y]\n      });\n    }),\n    translate: verbosify(['dx', 'dy'], function () {\n      var dx = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n      var dy = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      if (dx !== 0 || dy !== 0) {\n        var _ret = (function () {\n          var prev = [0, 0];\n          var matrix = [1, 0, 0, 1, dx, dy];\n          var newInstructions = _instructions.map(function (instruction) {\n            var p = transformParams(instruction, matrix, prev);\n            prev = point(instruction, prev);\n            return p;\n          });\n          return {\n            v: Path(newInstructions)\n          };\n        })();\n\n        if (typeof _ret === 'object') return _ret.v;\n      } else {\n        return Path(_instructions);\n      }\n    }),\n    rotate: verbosify(['angle', 'rx', 'ry'], function (angle) {\n      var rx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n      var ry = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n      if (angle !== 0) {\n        var _ret2 = (function () {\n          var prev = undefined;\n          var matrix = undefined;\n          var newInstructions = _instructions;\n\n          if (rx !== 0 && ry !== 0) {\n            prev = [0, 0];\n            matrix = [1, 0, 0, 1, -rx, -ry];\n            newInstructions = newInstructions.map(function (instruction) {\n              var p = transformParams(instruction, matrix, prev);\n              prev = point(instruction, prev);\n              return p;\n            });\n          }\n\n          var rad = angle * Math.PI / 180;\n          var cos = Math.cos(rad);\n          var sin = Math.sin(rad);\n\n          prev = [0, 0];\n          matrix = [cos, sin, -sin, cos, 0, 0];\n          newInstructions = newInstructions.map(function (instruction) {\n            var p = transformParams(instruction, matrix, prev);\n            prev = point(instruction, prev);\n            return p;\n          });\n\n          if (rx !== 0 && ry !== 0) {\n            prev = [0, 0];\n            matrix = [1, 0, 0, 1, rx, ry];\n            newInstructions = newInstructions.map(function (instruction) {\n              var p = transformParams(instruction, matrix, prev);\n              prev = point(instruction, prev);\n              return p;\n            });\n          }\n\n          return {\n            v: Path(newInstructions)\n          };\n        })();\n\n        if (typeof _ret2 === 'object') return _ret2.v;\n      } else {\n        return Path(_instructions);\n      }\n    }),\n    scale: verbosify(['sx', 'sy'], function () {\n      var sx = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n      var sy = arguments.length <= 1 || arguments[1] === undefined ? sx : arguments[1];\n      return (function () {\n        if (sx !== 1 || sy !== 1) {\n          var _ret3 = (function () {\n            var prev = [0, 0];\n            var matrix = [sx, 0, 0, sy, 0, 0];\n            var newInstructions = _instructions.map(function (instruction) {\n              var p = transformParams(instruction, matrix, prev);\n              prev = point(instruction, prev);\n              return p;\n            });\n            return {\n              v: Path(newInstructions)\n            };\n          })();\n\n          if (typeof _ret3 === 'object') return _ret3.v;\n        } else {\n          return Path(_instructions);\n        }\n      })();\n    }),\n    shearX: verbosify(['angle'], function () {\n      var angle = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n      if (angle !== 0) {\n        var _ret4 = (function () {\n          var prev = [0, 0];\n          var matrix = [1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0];\n          var newInstructions = _instructions.map(function (instruction) {\n            var p = transformParams(instruction, matrix, prev);\n            prev = point(instruction, prev);\n            return p;\n          });\n          return {\n            v: Path(newInstructions)\n          };\n        })();\n\n        if (typeof _ret4 === 'object') return _ret4.v;\n      } else {\n        return Path(_instructions);\n      }\n    }),\n    shearY: verbosify(['angle'], function () {\n      var angle = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n      if (angle !== 0) {\n        var _ret5 = (function () {\n          var prev = [0, 0];\n          var matrix = [1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0];\n          var newInstructions = _instructions.map(function (instruction) {\n            var p = transformParams(instruction, matrix, prev);\n            prev = point(instruction, prev);\n            return p;\n          });\n          return {\n            v: Path(newInstructions)\n          };\n        })();\n\n        if (typeof _ret5 === 'object') return _ret5.v;\n      } else {\n        return Path(_instructions);\n      }\n    }),\n    print: function print() {\n      return _instructions.map(printInstrunction).join(' ');\n    },\n    toString: function toString() {\n      return undefined.print();\n    },\n    points: function points() {\n      var ps = [];\n      var prev = [0, 0];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _instructions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var instruction = _step.value;\n\n          var p = point(instruction, prev);\n          prev = p;\n          if (p) {\n            ps.push(p);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return ps;\n    },\n    instructions: function instructions() {\n      return _instructions.slice(0, _instructions.length);\n    },\n    connect: function connect(path) {\n      var ps = this.points();\n      var last = ps[ps.length - 1];\n      var first = path.points()[0];\n      var newInstructions = undefined;\n      if (_instructions[_instructions.length - 1].command !== 'Z') {\n        newInstructions = path.instructions().slice(1);\n        if (!areEqualPoints(last, first)) {\n          newInstructions.unshift({\n            command: \"L\",\n            params: first\n          });\n        }\n      } else {\n        newInstructions = path.instructions();\n      }\n      return Path(this.instructions().concat(newInstructions));\n    }\n  };\n};\n\nexports[\"default\"] = function () {\n  return Path();\n};\n\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGF0aHMtanMvcGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsb0NBQW9DLGlDQUFpQyxlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSwyQ0FBMkMsVUFBVSxzQkFBc0IsZUFBZSwyQkFBMkIsMEJBQTBCLGNBQWMsMkNBQTJDLGdDQUFnQyxPQUFPLG1GQUFtRjs7QUFFdHBCLFlBQVksbUJBQU8sQ0FBQyxxREFBUTs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUJBQXFCLGtCQUFrQixJQUFJLGtCQUFrQixJQUFJLGtCQUFrQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UsZ0VBQWdFO0FBQ3RJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvcGF0aHMtanMvcGF0aC5qcz83ZjJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSkgX2lbJ3JldHVybiddKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTsgfSB9OyB9KSgpO1xuXG52YXIgX2dlb20gPSByZXF1aXJlKCcuL2dlb20nKTtcblxudmFyIFBhdGggPSBmdW5jdGlvbiBQYXRoKGluaXQpIHtcbiAgdmFyIF9pbnN0cnVjdGlvbnMgPSBpbml0IHx8IFtdO1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChhcnIsIGVsKSB7XG4gICAgdmFyIGNvcHkgPSBhcnIuc2xpY2UoMCwgYXJyLmxlbmd0aCk7XG4gICAgY29weS5wdXNoKGVsKTtcbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICB2YXIgYXJlRXF1YWxQb2ludHMgPSBmdW5jdGlvbiBhcmVFcXVhbFBvaW50cyhfcmVmLCBfcmVmMykge1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgdmFyIGExID0gX3JlZjJbMF07XG4gICAgdmFyIGIxID0gX3JlZjJbMV07XG5cbiAgICB2YXIgX3JlZjMyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpO1xuXG4gICAgdmFyIGEyID0gX3JlZjMyWzBdO1xuICAgIHZhciBiMiA9IF9yZWYzMlsxXTtcbiAgICByZXR1cm4gYTEgPT09IGEyICYmIGIxID09PSBiMjtcbiAgfTtcblxuICB2YXIgdHJpbVplcm9zID0gZnVuY3Rpb24gdHJpbVplcm9zKHN0cmluZywgY2hhcikge1xuICAgIHZhciBsID0gc3RyaW5nLmxlbmd0aDtcbiAgICB3aGlsZSAoc3RyaW5nLmNoYXJBdChsIC0gMSkgPT09ICcwJykge1xuICAgICAgbCA9IGwgLSAxO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nLmNoYXJBdChsIC0gMSkgPT09ICcuJykge1xuICAgICAgbCA9IGwgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBsKTtcbiAgfTtcblxuICB2YXIgcm91bmQgPSBmdW5jdGlvbiByb3VuZChudW1iZXIsIGRpZ2l0cykge1xuICAgIHZhciBzdHIgPSBudW1iZXIudG9GaXhlZChkaWdpdHMpO1xuICAgIHJldHVybiB0cmltWmVyb3Moc3RyKTtcbiAgfTtcblxuICB2YXIgcHJpbnRJbnN0cnVuY3Rpb24gPSBmdW5jdGlvbiBwcmludEluc3RydW5jdGlvbihfcmVmNCkge1xuICAgIHZhciBjb21tYW5kID0gX3JlZjQuY29tbWFuZDtcbiAgICB2YXIgcGFyYW1zID0gX3JlZjQucGFyYW1zO1xuXG4gICAgdmFyIG51bWJlcnMgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgcmV0dXJuIHJvdW5kKHBhcmFtLCA2KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29tbWFuZCArICcgJyArIG51bWJlcnMuam9pbignICcpO1xuICB9O1xuXG4gIHZhciBwb2ludCA9IGZ1bmN0aW9uIHBvaW50KF9yZWY1LCBwcmV2KSB7XG4gICAgdmFyIGNvbW1hbmQgPSBfcmVmNS5jb21tYW5kO1xuICAgIHZhciBwYXJhbXMgPSBfcmVmNS5wYXJhbXM7XG5cbiAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICByZXR1cm4gW3BhcmFtc1swXSwgcGFyYW1zWzFdXTtcbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICByZXR1cm4gW3BhcmFtc1swXSwgcGFyYW1zWzFdXTtcbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICByZXR1cm4gW3BhcmFtc1swXSwgcHJldlsxXV07XG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgcmV0dXJuIFtwcmV2WzBdLCBwYXJhbXNbMF1dO1xuICAgICAgY2FzZSAnWic6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSAnQyc6XG4gICAgICAgIHJldHVybiBbcGFyYW1zWzRdLCBwYXJhbXNbNV1dO1xuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIHJldHVybiBbcGFyYW1zWzJdLCBwYXJhbXNbM11dO1xuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIHJldHVybiBbcGFyYW1zWzJdLCBwYXJhbXNbM11dO1xuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIHJldHVybiBbcGFyYW1zWzBdLCBwYXJhbXNbMV1dO1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIHJldHVybiBbcGFyYW1zWzVdLCBwYXJhbXNbNl1dO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtUGFyYW1zID0gZnVuY3Rpb24gdHJhbnNmb3JtUGFyYW1zKGluc3RydWN0aW9uLCBtYXRyaXgsIHByZXYpIHtcbiAgICB2YXIgcCA9IGluc3RydWN0aW9uLnBhcmFtcztcblxuICAgIHZhciB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICdWJzogZnVuY3Rpb24gVihpbnN0cnVjdGlvbiwgbWF0cml4LCBwcmV2KSB7XG4gICAgICAgIHZhciBwdHMgPSBbeyB4OiBwcmV2WzBdLCB5OiBwWzBdIH1dO1xuICAgICAgICB2YXIgbmV3UHRzID0gKDAsIF9nZW9tLm1hdHJpeFRyYW5zZm9ybSkocHRzLCBtYXRyaXgpO1xuICAgICAgICBpZiAobmV3UHRzWzBdLnggPT09ICgwLCBfZ2VvbS5tYXRyaXhUcmFuc2Zvcm0pKFt7IHg6IHByZXZbMF0sIHk6IHByZXZbMV0gfV0sIG1hdHJpeClbMF0ueCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tYW5kOiAnVicsXG4gICAgICAgICAgICBwYXJhbXM6IFtuZXdQdHNbMF0ueV1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tYW5kOiAnTCcsXG4gICAgICAgICAgICBwYXJhbXM6IFtuZXdQdHNbMF0ueCwgbmV3UHRzWzBdLnldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdIJzogZnVuY3Rpb24gSChpbnN0cnVjdGlvbiwgbWF0cml4LCBwcmV2KSB7XG4gICAgICAgIHZhciBwdHMgPSBbeyB4OiBwWzBdLCB5OiBwcmV2WzFdIH1dO1xuICAgICAgICB2YXIgbmV3UHRzID0gKDAsIF9nZW9tLm1hdHJpeFRyYW5zZm9ybSkocHRzLCBtYXRyaXgpO1xuICAgICAgICBpZiAobmV3UHRzWzBdLnkgPT09ICgwLCBfZ2VvbS5tYXRyaXhUcmFuc2Zvcm0pKFt7IHg6IHByZXZbMF0sIHk6IHByZXZbMV0gfV0sIG1hdHJpeClbMF0ueSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tYW5kOiAnSCcsXG4gICAgICAgICAgICBwYXJhbXM6IFtuZXdQdHNbMF0ueF1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tYW5kOiAnTCcsXG4gICAgICAgICAgICBwYXJhbXM6IFtuZXdQdHNbMF0ueCwgbmV3UHRzWzBdLnldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdBJzogZnVuY3Rpb24gQShpbnN0cnVjdGlvbiwgbWF0cml4LCBwcmV2KSB7XG4gICAgICAgIC8vIHRyYW5zZm9ybSByeCwgcnksIGFuZCB4LWF4aXMgcm90YXRpb25cbiAgICAgICAgdmFyIHIgPSAoMCwgX2dlb20udHJhbnNmb3JtRWxsaXBzZSkocFswXSwgcFsxXSwgcFsyXSwgbWF0cml4KTtcblxuICAgICAgICB2YXIgc3dlZXBGbGFnID0gcFs0XTtcbiAgICAgICAgaWYgKG1hdHJpeFswXSAqIG1hdHJpeFszXSAtIG1hdHJpeFsxXSAqIG1hdHJpeFsyXSA8IDApIHtcbiAgICAgICAgICBzd2VlcEZsYWcgPSBzd2VlcEZsYWcgPyAnMCcgOiAnMSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2Zvcm0gZW5kcG9pbnRcbiAgICAgICAgdmFyIHB0cyA9IFt7IHg6IHBbNV0sIHk6IHBbNl0gfV07XG4gICAgICAgIHZhciBuZXdQdHMgPSAoMCwgX2dlb20ubWF0cml4VHJhbnNmb3JtKShwdHMsIG1hdHJpeCk7XG5cbiAgICAgICAgaWYgKHIuaXNEZWdlbmVyYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdMJyxcbiAgICAgICAgICAgIHBhcmFtczogW25ld1B0c1swXS54LCBuZXdQdHNbMF0ueV1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tYW5kOiAnQScsXG4gICAgICAgICAgICBwYXJhbXM6IFtyLnJ4LCByLnJ5LCByLmF4LCBwWzNdLCBzd2VlcEZsYWcsIG5ld1B0c1swXS54LCBuZXdQdHNbMF0ueV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ0MnOiBmdW5jdGlvbiBDKGluc3RydWN0aW9uLCBtYXRyaXgsIHByZXYpIHtcbiAgICAgICAgdmFyIHB0cyA9IFt7IHg6IHBbMF0sIHk6IHBbMV0gfSwgeyB4OiBwWzJdLCB5OiBwWzNdIH0sIHsgeDogcFs0XSwgeTogcFs1XSB9XTtcbiAgICAgICAgdmFyIG5ld1B0cyA9ICgwLCBfZ2VvbS5tYXRyaXhUcmFuc2Zvcm0pKHB0cywgbWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21tYW5kOiAnQycsXG4gICAgICAgICAgcGFyYW1zOiBbbmV3UHRzWzBdLngsIG5ld1B0c1swXS55LCBuZXdQdHNbMV0ueCwgbmV3UHRzWzFdLnksIG5ld1B0c1syXS54LCBuZXdQdHNbMl0ueV1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAnWic6IGZ1bmN0aW9uIFooaW5zdHJ1Y3Rpb24sIG1hdHJpeCwgcHJldikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbW1hbmQ6ICdaJyxcbiAgICAgICAgICBwYXJhbXM6IFtdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgJ2RlZmF1bHQnOiBmdW5jdGlvbiBfZGVmYXVsdChpbnN0cnVjdGlvbiwgbWF0cml4LCBwcmV2KSB7XG4gICAgICAgIHZhciBwdHMgPSBbeyB4OiBwWzBdLCB5OiBwWzFdIH1dO1xuICAgICAgICB2YXIgbmV3UHRzID0gKDAsIF9nZW9tLm1hdHJpeFRyYW5zZm9ybSkocHRzLCBtYXRyaXgpO1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gaW5zdHJ1Y3Rpb24ucGFyYW1zLnNsaWNlKDAsIGluc3RydWN0aW9uLnBhcmFtcy5sZW5ndGgpO1xuICAgICAgICBuZXdQYXJhbXMuc3BsaWNlKDAsIDIsIG5ld1B0c1swXS54LCBuZXdQdHNbMF0ueSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tbWFuZDogaW5zdHJ1Y3Rpb24uY29tbWFuZCxcbiAgICAgICAgICBwYXJhbXM6IG5ld1BhcmFtc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHJhbnNmb3JtZXJbaW5zdHJ1Y3Rpb24uY29tbWFuZF0pIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lcltpbnN0cnVjdGlvbi5jb21tYW5kXShpbnN0cnVjdGlvbiwgbWF0cml4LCBwcmV2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyWydkZWZhdWx0J10oaW5zdHJ1Y3Rpb24sIG1hdHJpeCwgcHJldik7XG4gICAgfVxuICB9O1xuXG4gIHZhciB2ZXJib3NpZnkgPSBmdW5jdGlvbiB2ZXJib3NpZnkoa2V5cywgZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgdmFyIGFyZ3MgPSB0eXBlb2YgYSA9PT0gJ29iamVjdCcgPyBrZXlzLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gYVtrXTtcbiAgICAgIH0pIDogYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgcGx1cyA9IGZ1bmN0aW9uIHBsdXMoaW5zdHJ1Y3Rpb24pIHtcbiAgICByZXR1cm4gUGF0aChwdXNoKF9pbnN0cnVjdGlvbnMsIGluc3RydWN0aW9uKSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtb3ZldG86IHZlcmJvc2lmeShbJ3gnLCAneSddLCBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHBsdXMoe1xuICAgICAgICBjb21tYW5kOiAnTScsXG4gICAgICAgIHBhcmFtczogW3gsIHldXG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBsaW5ldG86IHZlcmJvc2lmeShbJ3gnLCAneSddLCBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHBsdXMoe1xuICAgICAgICBjb21tYW5kOiAnTCcsXG4gICAgICAgIHBhcmFtczogW3gsIHldXG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBobGluZXRvOiB2ZXJib3NpZnkoWyd4J10sIGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcGx1cyh7XG4gICAgICAgIGNvbW1hbmQ6ICdIJyxcbiAgICAgICAgcGFyYW1zOiBbeF1cbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHZsaW5ldG86IHZlcmJvc2lmeShbJ3knXSwgZnVuY3Rpb24gKHkpIHtcbiAgICAgIHJldHVybiBwbHVzKHtcbiAgICAgICAgY29tbWFuZDogJ1YnLFxuICAgICAgICBwYXJhbXM6IFt5XVxuICAgICAgfSk7XG4gICAgfSksXG4gICAgY2xvc2VwYXRoOiBmdW5jdGlvbiBjbG9zZXBhdGgoKSB7XG4gICAgICByZXR1cm4gcGx1cyh7XG4gICAgICAgIGNvbW1hbmQ6ICdaJyxcbiAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjdXJ2ZXRvOiB2ZXJib3NpZnkoWyd4MScsICd5MScsICd4MicsICd5MicsICd4JywgJ3knXSwgZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICByZXR1cm4gcGx1cyh7XG4gICAgICAgIGNvbW1hbmQ6ICdDJyxcbiAgICAgICAgcGFyYW1zOiBbeDEsIHkxLCB4MiwgeTIsIHgsIHldXG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBzbW9vdGhjdXJ2ZXRvOiB2ZXJib3NpZnkoWyd4MicsICd5MicsICd4JywgJ3knXSwgZnVuY3Rpb24gKHgyLCB5MiwgeCwgeSkge1xuICAgICAgcmV0dXJuIHBsdXMoe1xuICAgICAgICBjb21tYW5kOiAnUycsXG4gICAgICAgIHBhcmFtczogW3gyLCB5MiwgeCwgeV1cbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHFjdXJ2ZXRvOiB2ZXJib3NpZnkoWyd4MScsICd5MScsICd4JywgJ3knXSwgZnVuY3Rpb24gKHgxLCB5MSwgeCwgeSkge1xuICAgICAgcmV0dXJuIHBsdXMoe1xuICAgICAgICBjb21tYW5kOiAnUScsXG4gICAgICAgIHBhcmFtczogW3gxLCB5MSwgeCwgeV1cbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHNtb290aHFjdXJ2ZXRvOiB2ZXJib3NpZnkoWyd4JywgJ3knXSwgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiBwbHVzKHtcbiAgICAgICAgY29tbWFuZDogJ1QnLFxuICAgICAgICBwYXJhbXM6IFt4LCB5XVxuICAgICAgfSk7XG4gICAgfSksXG4gICAgYXJjOiB2ZXJib3NpZnkoWydyeCcsICdyeScsICd4cm90JywgJ2xhcmdlQXJjRmxhZycsICdzd2VlcEZsYWcnLCAneCcsICd5J10sIGZ1bmN0aW9uIChyeCwgcnksIHhyb3QsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XG4gICAgICByZXR1cm4gcGx1cyh7XG4gICAgICAgIGNvbW1hbmQ6ICdBJyxcbiAgICAgICAgcGFyYW1zOiBbcngsIHJ5LCB4cm90LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeV1cbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHRyYW5zbGF0ZTogdmVyYm9zaWZ5KFsnZHgnLCAnZHknXSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGR4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuICAgICAgICB2YXIgX3JldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBbMCwgMF07XG4gICAgICAgICAgdmFyIG1hdHJpeCA9IFsxLCAwLCAwLCAxLCBkeCwgZHldO1xuICAgICAgICAgIHZhciBuZXdJbnN0cnVjdGlvbnMgPSBfaW5zdHJ1Y3Rpb25zLm1hcChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBwID0gdHJhbnNmb3JtUGFyYW1zKGluc3RydWN0aW9uLCBtYXRyaXgsIHByZXYpO1xuICAgICAgICAgICAgcHJldiA9IHBvaW50KGluc3RydWN0aW9uLCBwcmV2KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2OiBQYXRoKG5ld0luc3RydWN0aW9ucylcbiAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3JldCA9PT0gJ29iamVjdCcpIHJldHVybiBfcmV0LnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUGF0aChfaW5zdHJ1Y3Rpb25zKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICByb3RhdGU6IHZlcmJvc2lmeShbJ2FuZ2xlJywgJ3J4JywgJ3J5J10sIGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgdmFyIHJ4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciByeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgICB2YXIgX3JldDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBwcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHZhciBtYXRyaXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIG5ld0luc3RydWN0aW9ucyA9IF9pbnN0cnVjdGlvbnM7XG5cbiAgICAgICAgICBpZiAocnggIT09IDAgJiYgcnkgIT09IDApIHtcbiAgICAgICAgICAgIHByZXYgPSBbMCwgMF07XG4gICAgICAgICAgICBtYXRyaXggPSBbMSwgMCwgMCwgMSwgLXJ4LCAtcnldO1xuICAgICAgICAgICAgbmV3SW5zdHJ1Y3Rpb25zID0gbmV3SW5zdHJ1Y3Rpb25zLm1hcChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSB0cmFuc2Zvcm1QYXJhbXMoaW5zdHJ1Y3Rpb24sIG1hdHJpeCwgcHJldik7XG4gICAgICAgICAgICAgIHByZXYgPSBwb2ludChpbnN0cnVjdGlvbiwgcHJldik7XG4gICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJhZCA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MocmFkKTtcbiAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkKTtcblxuICAgICAgICAgIHByZXYgPSBbMCwgMF07XG4gICAgICAgICAgbWF0cml4ID0gW2Nvcywgc2luLCAtc2luLCBjb3MsIDAsIDBdO1xuICAgICAgICAgIG5ld0luc3RydWN0aW9ucyA9IG5ld0luc3RydWN0aW9ucy5tYXAoZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRyYW5zZm9ybVBhcmFtcyhpbnN0cnVjdGlvbiwgbWF0cml4LCBwcmV2KTtcbiAgICAgICAgICAgIHByZXYgPSBwb2ludChpbnN0cnVjdGlvbiwgcHJldik7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChyeCAhPT0gMCAmJiByeSAhPT0gMCkge1xuICAgICAgICAgICAgcHJldiA9IFswLCAwXTtcbiAgICAgICAgICAgIG1hdHJpeCA9IFsxLCAwLCAwLCAxLCByeCwgcnldO1xuICAgICAgICAgICAgbmV3SW5zdHJ1Y3Rpb25zID0gbmV3SW5zdHJ1Y3Rpb25zLm1hcChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSB0cmFuc2Zvcm1QYXJhbXMoaW5zdHJ1Y3Rpb24sIG1hdHJpeCwgcHJldik7XG4gICAgICAgICAgICAgIHByZXYgPSBwb2ludChpbnN0cnVjdGlvbiwgcHJldik7XG4gICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHY6IFBhdGgobmV3SW5zdHJ1Y3Rpb25zKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfcmV0MiA9PT0gJ29iamVjdCcpIHJldHVybiBfcmV0Mi52O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFBhdGgoX2luc3RydWN0aW9ucyk7XG4gICAgICB9XG4gICAgfSksXG4gICAgc2NhbGU6IHZlcmJvc2lmeShbJ3N4JywgJ3N5J10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzeCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IDEgOiBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgc3kgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBzeCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc3ggIT09IDEgfHwgc3kgIT09IDEpIHtcbiAgICAgICAgICB2YXIgX3JldDMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBbMCwgMF07XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gW3N4LCAwLCAwLCBzeSwgMCwgMF07XG4gICAgICAgICAgICB2YXIgbmV3SW5zdHJ1Y3Rpb25zID0gX2luc3RydWN0aW9ucy5tYXAoZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gdHJhbnNmb3JtUGFyYW1zKGluc3RydWN0aW9uLCBtYXRyaXgsIHByZXYpO1xuICAgICAgICAgICAgICBwcmV2ID0gcG9pbnQoaW5zdHJ1Y3Rpb24sIHByZXYpO1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdjogUGF0aChuZXdJbnN0cnVjdGlvbnMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIF9yZXQzID09PSAnb2JqZWN0JykgcmV0dXJuIF9yZXQzLnY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFBhdGgoX2luc3RydWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSksXG4gICAgc2hlYXJYOiB2ZXJib3NpZnkoWydhbmdsZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYW5nbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgICAgdmFyIF9yZXQ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcHJldiA9IFswLCAwXTtcbiAgICAgICAgICB2YXIgbWF0cml4ID0gWzEsIDAsIE1hdGgudGFuKGFuZ2xlICogTWF0aC5QSSAvIDE4MCksIDEsIDAsIDBdO1xuICAgICAgICAgIHZhciBuZXdJbnN0cnVjdGlvbnMgPSBfaW5zdHJ1Y3Rpb25zLm1hcChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBwID0gdHJhbnNmb3JtUGFyYW1zKGluc3RydWN0aW9uLCBtYXRyaXgsIHByZXYpO1xuICAgICAgICAgICAgcHJldiA9IHBvaW50KGluc3RydWN0aW9uLCBwcmV2KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2OiBQYXRoKG5ld0luc3RydWN0aW9ucylcbiAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3JldDQgPT09ICdvYmplY3QnKSByZXR1cm4gX3JldDQudjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQYXRoKF9pbnN0cnVjdGlvbnMpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIHNoZWFyWTogdmVyYm9zaWZ5KFsnYW5nbGUnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFuZ2xlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICAgIHZhciBfcmV0NSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBbMCwgMF07XG4gICAgICAgICAgdmFyIG1hdHJpeCA9IFsxLCBNYXRoLnRhbihhbmdsZSAqIE1hdGguUEkgLyAxODApLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICB2YXIgbmV3SW5zdHJ1Y3Rpb25zID0gX2luc3RydWN0aW9ucy5tYXAoZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRyYW5zZm9ybVBhcmFtcyhpbnN0cnVjdGlvbiwgbWF0cml4LCBwcmV2KTtcbiAgICAgICAgICAgIHByZXYgPSBwb2ludChpbnN0cnVjdGlvbiwgcHJldik7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjogUGF0aChuZXdJbnN0cnVjdGlvbnMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBpZiAodHlwZW9mIF9yZXQ1ID09PSAnb2JqZWN0JykgcmV0dXJuIF9yZXQ1LnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUGF0aChfaW5zdHJ1Y3Rpb25zKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBwcmludDogZnVuY3Rpb24gcHJpbnQoKSB7XG4gICAgICByZXR1cm4gX2luc3RydWN0aW9ucy5tYXAocHJpbnRJbnN0cnVuY3Rpb24pLmpvaW4oJyAnKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQucHJpbnQoKTtcbiAgICB9LFxuICAgIHBvaW50czogZnVuY3Rpb24gcG9pbnRzKCkge1xuICAgICAgdmFyIHBzID0gW107XG4gICAgICB2YXIgcHJldiA9IFswLCAwXTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfaW5zdHJ1Y3Rpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHAgPSBwb2ludChpbnN0cnVjdGlvbiwgcHJldik7XG4gICAgICAgICAgcHJldiA9IHA7XG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHBzLnB1c2gocCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvclsncmV0dXJuJ10pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvclsncmV0dXJuJ10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBzO1xuICAgIH0sXG4gICAgaW5zdHJ1Y3Rpb25zOiBmdW5jdGlvbiBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICByZXR1cm4gX2luc3RydWN0aW9ucy5zbGljZSgwLCBfaW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiBmdW5jdGlvbiBjb25uZWN0KHBhdGgpIHtcbiAgICAgIHZhciBwcyA9IHRoaXMucG9pbnRzKCk7XG4gICAgICB2YXIgbGFzdCA9IHBzW3BzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGZpcnN0ID0gcGF0aC5wb2ludHMoKVswXTtcbiAgICAgIHZhciBuZXdJbnN0cnVjdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoX2luc3RydWN0aW9uc1tfaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdLmNvbW1hbmQgIT09ICdaJykge1xuICAgICAgICBuZXdJbnN0cnVjdGlvbnMgPSBwYXRoLmluc3RydWN0aW9ucygpLnNsaWNlKDEpO1xuICAgICAgICBpZiAoIWFyZUVxdWFsUG9pbnRzKGxhc3QsIGZpcnN0KSkge1xuICAgICAgICAgIG5ld0luc3RydWN0aW9ucy51bnNoaWZ0KHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IFwiTFwiLFxuICAgICAgICAgICAgcGFyYW1zOiBmaXJzdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdJbnN0cnVjdGlvbnMgPSBwYXRoLmluc3RydWN0aW9ucygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFBhdGgodGhpcy5pbnN0cnVjdGlvbnMoKS5jb25jYXQobmV3SW5zdHJ1Y3Rpb25zKSk7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUGF0aCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/paths-js/path.js\n");

/***/ })

};
;